#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <SDL.h>
#include "em.h"

struct xstate {
	SDL_Renderer *renderer;
	SDL_Texture *texture;
	SDL_Texture *font;
	Uint32 *pixels;
	int lastwidth;
	int screen_dirty;
};

#define BUFFLEN 0x1000
#define INLEN 4096

#define IXSIZE 324
#define IYSIZE 224
int mapconv[256];
unsigned char *indata;
int pos=15;
int cwidth=64;
int xoff=0,yoff=0;
unsigned char currentmap[768];
int logfile=-1;
#define BS 0x08
int colortranslate[65536];
int video32[224*320];
int zoom=4;

ec theec;

unsigned char fontdata[96][13]={
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,0x04,0x00,0x00,0x00},
{0x00,0x0a,0x0a,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0x00,0x00,0x0a,0x0a,0x1f,0x0a,0x1f,0x0a,0x0a,0x00,0x00,0x00,0x00},
{0x00,0x04,0x1e,0x05,0x05,0x0e,0x14,0x14,0x0f,0x04,0x00,0x00,0x00},
{0x00,0x12,0x15,0x0a,0x08,0x04,0x02,0x0a,0x15,0x09,0x00,0x00,0x00},
{0x00,0x02,0x05,0x05,0x02,0x05,0x19,0x09,0x16,0x00,0x00,0x00,0x00},
{0x00,0x0c,0x04,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0x00,0x08,0x04,0x04,0x02,0x02,0x02,0x04,0x04,0x08,0x00,0x00,0x00},
{0x00,0x02,0x04,0x04,0x08,0x08,0x08,0x04,0x04,0x02,0x00,0x00,0x00},
{0x00,0x00,0x04,0x15,0x1f,0x0e,0x1f,0x15,0x04,0x00,0x00,0x00,0x00},
{0x00,0x00,0x00,0x04,0x04,0x1f,0x04,0x04,0x00,0x00,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x04,0x02,0x00,0x00},
{0x00,0x00,0x00,0x00,0x00,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x0e,0x04,0x00,0x00},
{0x00,0x10,0x10,0x08,0x08,0x04,0x02,0x02,0x01,0x01,0x00,0x00,0x00},
{0x00,0x04,0x0a,0x11,0x11,0x11,0x11,0x11,0x0a,0x04,0x00,0x00,0x00},
{0x00,0x04,0x06,0x05,0x04,0x04,0x04,0x04,0x04,0x1f,0x00,0x00,0x00},
{0x00,0x0e,0x11,0x11,0x10,0x08,0x04,0x02,0x01,0x1f,0x00,0x00,0x00},
{0x00,0x1f,0x10,0x08,0x04,0x0e,0x10,0x10,0x11,0x0e,0x00,0x00,0x00},
{0x00,0x08,0x08,0x0c,0x0a,0x0a,0x09,0x1f,0x08,0x08,0x00,0x00,0x00},
{0x00,0x1f,0x01,0x01,0x0d,0x13,0x10,0x10,0x11,0x0e,0x00,0x00,0x00},
{0x00,0x0e,0x11,0x01,0x01,0x0f,0x11,0x11,0x11,0x0e,0x00,0x00,0x00},
{0x00,0x1f,0x10,0x08,0x08,0x04,0x04,0x02,0x02,0x02,0x00,0x00,0x00},
{0x00,0x0e,0x11,0x11,0x11,0x0e,0x11,0x11,0x11,0x0e,0x00,0x00,0x00},
{0x00,0x0e,0x11,0x11,0x11,0x1e,0x10,0x10,0x11,0x0e,0x00,0x00,0x00},
{0x00,0x00,0x00,0x04,0x0e,0x04,0x00,0x00,0x04,0x0e,0x04,0x00,0x00},
{0x00,0x00,0x00,0x04,0x0e,0x04,0x00,0x00,0x0c,0x04,0x02,0x00,0x00},
{0x00,0x10,0x08,0x04,0x02,0x01,0x02,0x04,0x08,0x10,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x1f,0x00,0x00,0x1f,0x00,0x00,0x00,0x00,0x00},
{0x00,0x01,0x02,0x04,0x08,0x10,0x08,0x04,0x02,0x01,0x00,0x00,0x00},
{0x00,0x0e,0x11,0x11,0x10,0x08,0x04,0x04,0x00,0x04,0x00,0x00,0x00},
{0x00,0x0e,0x11,0x11,0x19,0x15,0x15,0x0d,0x01,0x1e,0x00,0x00,0x00},
{0x00,0x04,0x0a,0x11,0x11,0x11,0x1f,0x11,0x11,0x11,0x00,0x00,0x00},
{0x00,0x0f,0x12,0x12,0x12,0x0e,0x12,0x12,0x12,0x0f,0x00,0x00,0x00},
{0x00,0x0e,0x11,0x01,0x01,0x01,0x01,0x01,0x11,0x0e,0x00,0x00,0x00},
{0x00,0x0f,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x0f,0x00,0x00,0x00},
{0x00,0x1f,0x01,0x01,0x01,0x0f,0x01,0x01,0x01,0x1f,0x00,0x00,0x00},
{0x00,0x1f,0x01,0x01,0x01,0x0f,0x01,0x01,0x01,0x01,0x00,0x00,0x00},
{0x00,0x0e,0x11,0x01,0x01,0x01,0x19,0x11,0x11,0x0e,0x00,0x00,0x00},
{0x00,0x11,0x11,0x11,0x11,0x1f,0x11,0x11,0x11,0x11,0x00,0x00,0x00},
{0x00,0x0e,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x0e,0x00,0x00,0x00},
{0x00,0x1c,0x08,0x08,0x08,0x08,0x08,0x08,0x09,0x06,0x00,0x00,0x00},
{0x00,0x11,0x11,0x09,0x05,0x03,0x05,0x09,0x11,0x11,0x00,0x00,0x00},
{0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x1f,0x00,0x00,0x00},
{0x00,0x11,0x11,0x1b,0x15,0x15,0x11,0x11,0x11,0x11,0x00,0x00,0x00},
{0x00,0x11,0x13,0x13,0x15,0x15,0x19,0x19,0x11,0x11,0x00,0x00,0x00},
{0x00,0x0e,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x0e,0x00,0x00,0x00},
{0x00,0x0f,0x11,0x11,0x11,0x0f,0x01,0x01,0x01,0x01,0x00,0x00,0x00},
{0x00,0x0e,0x11,0x11,0x11,0x11,0x11,0x11,0x15,0x0e,0x10,0x00,0x00},
{0x00,0x0f,0x11,0x11,0x11,0x0f,0x05,0x09,0x11,0x11,0x00,0x00,0x00},
{0x00,0x0e,0x11,0x01,0x01,0x0e,0x10,0x10,0x11,0x0e,0x00,0x00,0x00},
{0x00,0x1f,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,0x00,0x00},
{0x00,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x0e,0x00,0x00,0x00},
{0x00,0x11,0x11,0x11,0x11,0x0a,0x0a,0x0a,0x04,0x04,0x00,0x00,0x00},
{0x00,0x11,0x11,0x11,0x11,0x15,0x15,0x15,0x1b,0x11,0x00,0x00,0x00},
{0x00,0x11,0x11,0x0a,0x0a,0x04,0x0a,0x0a,0x11,0x11,0x00,0x00,0x00},
{0x00,0x11,0x11,0x0a,0x0a,0x04,0x04,0x04,0x04,0x04,0x00,0x00,0x00},
{0x00,0x1f,0x10,0x08,0x08,0x04,0x02,0x02,0x01,0x1f,0x00,0x00,0x00},
{0x00,0x0e,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x0e,0x00,0x00,0x00},
{0x00,0x01,0x01,0x02,0x02,0x04,0x08,0x08,0x10,0x10,0x00,0x00,0x00},
{0x00,0x0e,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x0e,0x00,0x00,0x00},
{0x00,0x04,0x0a,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x00,0x00},
{0x00,0x0c,0x08,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x0e,0x10,0x1e,0x11,0x11,0x1e,0x00,0x00,0x00},
{0x00,0x01,0x01,0x01,0x0f,0x11,0x11,0x11,0x11,0x0f,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x0e,0x11,0x01,0x01,0x11,0x0e,0x00,0x00,0x00},
{0x00,0x10,0x10,0x10,0x1e,0x11,0x11,0x11,0x11,0x1e,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x0e,0x11,0x1f,0x01,0x11,0x0e,0x00,0x00,0x00},
{0x00,0x0c,0x12,0x02,0x02,0x0f,0x02,0x02,0x02,0x02,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x0e,0x11,0x11,0x11,0x1e,0x10,0x11,0x0e,0x00},
{0x00,0x01,0x01,0x01,0x0d,0x13,0x11,0x11,0x11,0x11,0x00,0x00,0x00},
{0x00,0x00,0x04,0x00,0x06,0x04,0x04,0x04,0x04,0x0e,0x00,0x00,0x00},
{0x00,0x00,0x08,0x00,0x0c,0x08,0x08,0x08,0x08,0x09,0x09,0x06,0x00},
{0x00,0x01,0x01,0x01,0x09,0x05,0x03,0x05,0x09,0x11,0x00,0x00,0x00},
{0x00,0x06,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x0e,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x0b,0x15,0x15,0x15,0x15,0x11,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x0d,0x13,0x11,0x11,0x11,0x11,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x0e,0x11,0x11,0x11,0x11,0x0e,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x0f,0x11,0x11,0x11,0x0f,0x01,0x01,0x01,0x00},
{0x00,0x00,0x00,0x00,0x1e,0x11,0x11,0x11,0x1e,0x10,0x10,0x10,0x00},
{0x00,0x00,0x00,0x00,0x0d,0x13,0x01,0x01,0x01,0x01,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x0e,0x11,0x06,0x08,0x11,0x0e,0x00,0x00,0x00},
{0x00,0x00,0x02,0x02,0x0f,0x02,0x02,0x02,0x12,0x0c,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x11,0x11,0x11,0x11,0x19,0x16,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x11,0x11,0x11,0x0a,0x0a,0x04,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x11,0x11,0x15,0x15,0x15,0x0a,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x11,0x0a,0x04,0x04,0x0a,0x11,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x11,0x11,0x11,0x19,0x16,0x10,0x11,0x0e,0x00},
{0x00,0x00,0x00,0x00,0x1f,0x08,0x04,0x02,0x01,0x1f,0x00,0x00,0x00},
{0x00,0x18,0x04,0x04,0x04,0x03,0x04,0x04,0x04,0x18,0x00,0x00,0x00},
{0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,0x00,0x00},
{0x00,0x03,0x04,0x04,0x04,0x18,0x04,0x04,0x04,0x03,0x00,0x00,0x00},
{0x00,0x12,0x15,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0x00,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x00}};



Uint32 maprgb(ec *ec, int r,int g,int b)
{
	return ((r&255)<<16) | ((g&255)<<8) | ((b&255)<<0);
}


#define ENDMARK 0xaabacada


int sdlinout[]={
SDLK_0,'0',')',
SDLK_1,'1','!',
SDLK_2,'2','@',
SDLK_3,'3','#',
SDLK_4,'4','$',
SDLK_5,'5','%',
SDLK_6,'6','^',
SDLK_7,'7','&',
SDLK_8,'8','*',
SDLK_9,'9','(',
SDLK_a,'a','A',
SDLK_b,'b','B',
SDLK_c,'c','C',
SDLK_d,'d','D',
SDLK_e,'e','E',
SDLK_f,'f','F',
SDLK_g,'g','G',
SDLK_h,'h','H',
SDLK_i,'i','I',
SDLK_j,'j','J',
SDLK_k,'k','K',
SDLK_l,'l','L',
SDLK_m,'m','M',
SDLK_n,'n','N',
SDLK_o,'o','O',
SDLK_p,'p','P',
SDLK_q,'q','Q',
SDLK_r,'r','R',
SDLK_s,'s','S',
SDLK_t,'t','T',
SDLK_u,'u','U',
SDLK_v,'v','V',
SDLK_w,'w','W',
SDLK_x,'x','X',
SDLK_y,'y','Y',
SDLK_z,'z','Z',
SDLK_MINUS,'-','_',
SDLK_EQUALS,'=','+',
SDLK_LEFTBRACKET,'[','{',
SDLK_RIGHTBRACKET,']','}',
SDLK_SEMICOLON,';',':',
SDLK_QUOTE,'\'','"',
SDLK_BACKSLASH,'\\','|',
SDLK_SLASH,'/','?',
SDLK_PERIOD,'.','>',
SDLK_COMMA,',','<',
SDLK_BACKQUOTE,'`','~',
SDLK_BACKSPACE,8,8,
SDLK_TAB,9,9,
SDLK_DELETE,MYDELETE,MYDELETE,
SDLK_RETURN,13,13,
SDLK_F1,MYF1,MYF1,
SDLK_F2,MYF2,MYF2,
SDLK_F3,MYF3,MYF3,
SDLK_F4,MYF4,MYF4,
SDLK_F5,MYF5,MYF5,
SDLK_F6,MYF6,MYF6,
SDLK_F7,MYF7,MYF7,
SDLK_F8,MYF8,MYF8,
SDLK_F9,MYF9,MYF9,
SDLK_F10,MYF10,MYF10,
SDLK_ESCAPE,0x1b,0x1b,
SDLK_LEFT,MYLEFT,MYLEFT,
SDLK_RIGHT,MYRIGHT,MYRIGHT,
SDLK_UP,MYUP,MYUP,
SDLK_DOWN,MYDOWN,MYDOWN,
SDLK_PAGEUP,MYPAGEUP,MYPAGEUP|MYSHIFTED,
SDLK_PAGEDOWN,MYPAGEDOWN,MYPAGEDOWN|MYSHIFTED,
SDLK_SPACE,' ',' ',
SDLK_HOME,MYHOME,MYHOME,
SDLK_END,MYEND,MYEND,
SDLK_LALT,MYALTL,MYALTL,
SDLK_RALT,MYALTR,MYALTR,
SDLK_LCTRL,MYCTRLL,MYCTRLL,
SDLK_RCTRL,MYCTRLR,MYCTRLR,
SDLK_LSHIFT,MYSHIFTL,MYSHIFTL,
SDLK_RSHIFT,MYSHIFTR,MYSHIFTR,
ENDMARK
};


#define NORMAL 0
#define CURSOR 4

int fontxsize,fontysize;
int xpsize,ypsize,txsize,tysize,xsize,ysize;

void mapkey(int code,int qual,int *mapped)
{
int *list;
	list=sdlinout;
	while(*list!=ENDMARK)
	{
		if(*list==code) break;
		list+=3;
	}
	if(*list==ENDMARK)
	{
		*mapped=mapped[1]=-1;
		return;
	}
	*mapped=(qual&KMOD_SHIFT) ? list[2] : list[1];
	if(qual & KMOD_ALT)
		*mapped|=MYALTED;
	if(qual & KMOD_CTRL)
		*mapped&=0x1f;
	mapped[1]=list[1];
}

int checkpressed(int code)
{
	int *p,i;
	ec *ec=&theec;

	i=ec->numpressed;
	p=ec->pressedcodes;
	while(i--)
		if(*p++==code) return 1;
	return 0;
}

void showpressed(void) {
	ec *ec=&theec;
	if(!ec->numpressed) return;
	int i;
	printf("Pressed:");
	for(i=0;i<ec->numpressed;++i)
		printf("%9x", ec->pressedcodes[i]);
	printf("\n");
}

void markkey(ec *ec, int code,int mod,int status)
{
	int i;
	int *ip;
	int mapped[2];

	mapkey(code,mod,mapped);
	code = mapped[1];
	if(code<0) return;
	if(status)
	{
		if(ec->numdown<KEYMAX)
			ec->downcodes[ec->numdown++]=code;
		ip=ec->pressedcodes;
		i=ec->numpressed;
		while(i)
			if(*ip++==code) break;
			else i--;
		if(!i && ec->numpressed<KEYMAX)
			ec->pressedcodes[ec->numpressed++]=code;
	} else
	{
		i=ec->numpressed;
		ip=ec->pressedcodes;
		while(i)
			if(*ip++==code)
			{
				*--ip=ec->pressedcodes[--ec->numpressed];
				break;
			} else i--;
	}
}

int ignorable(int code)
{
	return code==MYALTL || code==MYALTR || 
		code==MYCTRLL || code==MYCTRLR ||
		code==MYSHIFTL || code==MYSHIFTR || code<0;
}

void copyup(ec *ec)
{
	struct xstate *xstate = ec->xstate;
	SDL_RenderPresent(xstate->renderer);
}

inline void setcolor(ec *ec, int c)
{
	struct xstate *xstate = ec->xstate;
	SDL_SetRenderDrawColor(xstate->renderer, ((c>>16)&255), (c>>16)&255, (c>>0)&255, 255);
}
void colordot(ec *ec, Uint32 x,Uint32 y,int c)
{
	struct xstate *xstate = ec->xstate;
	setcolor(ec, c);
	SDL_RenderDrawPoint(xstate->renderer, x, y);
}
void colorrect(ec *ec, int x, int y, int w, int h, int c)
{
	struct xstate *xstate = ec->xstate;
	setcolor(ec, c);
	SDL_Rect r = {x, y, w, h};
	SDL_RenderFillRect(xstate->renderer, &r);
}

void doresize(ec *ec, int w, int h)
{
	xpsize=w;
	ypsize=h;
	((struct xstate *)(ec->xstate))->screen_dirty = 1;
}



void init_cmap(ec *ec)
{
int i;
int r,g,b;

	for(i=0;i<0x800;i++)
	{
		b=(i & 0x0700)>>3;
		g=(i & 0x070) << 1;
		r=(i & 0x007) << 5;
		colortranslate[i]=maprgb(ec, r,g,b);
	}
}

void closex()
{
}


void drawchar(ec *ec, int x, int y, int c)
{
	struct xstate *xstate = ec->xstate;
	int co = c;
	c &= 0x7f;
	if(c<' ' || c>=128)
		return;
	c -= ' ';

	SDL_Rect rs, rd;

	rs.x = 8*(c&15);
	rs.y = 13*(c>>4) + (co&128);
	rs.w = 6;
	rs.h = 13;

	rd.x = x;
	rd.y = y;
	rd.w = 6;
	rd.h = 13;
	SDL_RenderCopy(xstate->renderer, xstate->font, &rs, &rd);
}

void display(int changed)
{
	int i,j;
	ec *ec=&theec;
	int docopy = 0;
	
	struct xstate *xstate = ec->xstate;
	int width=(gfxregs[12]&1) ? 320 : 256;
	int height=224;

	if(changed)
		xstate->screen_dirty = 1;

	int pw, ph;
	if(ypsize*4/3 > xpsize) {
		pw = xpsize;
		ph = pw*3/4;
	} else {
		ph = ypsize;
		pw = ph*4/3;
	}

	int x = (xpsize - pw)/2;
	int y = (ypsize - ph)/2;

	if(xstate->screen_dirty)
	{
		int *ip=video32;
		for(j=0;j<height;j++)
		{
			Uint32 *p = xstate->pixels + j*320;
			for(i=0;i<width;i++)
				p[i] = ip[i];
			ip += 320;
		}
		SDL_UpdateTexture(xstate->texture, 0, xstate->pixels, 320*sizeof(Uint32));
		SDL_Rect r, s;
		s.x=0;
		s.y=0;
		s.w=width;
		s.h=height;
		r.x = x;
		r.y = y;
		r.w = pw;
		r.h = ph;
		SDL_RenderCopy(xstate->renderer, xstate->texture, &s, &r);
		xstate->screen_dirty=0;
		docopy = 1;
	}

	if(docopy)
		copyup(&theec);
}

void makefont(ec *ec)
{
	struct xstate *xstate = ec->xstate;
	const int ftw = 128, fth = 256;
	Uint32 *pixels = calloc(4, ftw*fth), *p;
	int i, j;
	for(j=0;j<2;++j)
	{
		int fg, bg;
		if(j==0)
		{
			fg = maprgb(ec, 255, 255, 255);
			bg = maprgb(ec, 0, 0, 0);
		} else
		{
			fg = maprgb(ec, 0, 0, 0);
			bg = maprgb(ec, 255, 0, 0);
		}
		for(i=0;i<96;++i)
		{
			int x, y;
			x = 8*(i&15);
			y = 13*(i>>4) + j*128;
			p = pixels + x + y*ftw;
			int v;
			unsigned char *cp = fontdata[i];
			for(v=0;v<13;++v)
			{
				int c = cp[v];
				p[0]= (c&0x01) ? fg : bg;
				p[1]= (c&0x02) ? fg : bg;
				p[2]= (c&0x04) ? fg : bg;
				p[3]= (c&0x08) ? fg : bg;
				p[4]= (c&0x10) ? fg : bg;
				p[5]= (c&0x20) ? fg : bg;
				p += 128;
			}
		}
	}
	xstate->font = SDL_CreateTexture(xstate->renderer,SDL_PIXELFORMAT_ARGB8888,
				SDL_TEXTUREACCESS_STREAMING, ftw, fth);
	SDL_UpdateTexture(xstate->font, 0, pixels, ftw*sizeof(Uint32));

	free(pixels);
}

void doxevents(void)
{
	SDL_Event event;
	int key,mod;
	ec *ec = &theec;
	int mapped[2];

	ec->numdown=0;
	while(SDL_PollEvent(&event))
	{
		switch(event.type)
		{
		case SDL_KEYDOWN:
			if(event.key.repeat) break; // it's an autorepeat
			key=event.key.keysym.sym;
			mod=event.key.keysym.mod;
			markkey(ec, key,mod,1);
			mapkey(key, mod, mapped);
			if(!ignorable(mapped[1])) {
				processkey(mapped[0]);
			}
			break;
		case SDL_KEYUP:
			key=event.key.keysym.sym;
			mod=event.key.keysym.mod;
			markkey(ec, key,mod,0);
			break;
		case SDL_MOUSEBUTTONUP:
//			bc->mouseb&=~(1<<(event.button.button-1));
//			bc->mousex=event.button.x;
//			bc->mousey=event.button.y;
			break;
		case SDL_MOUSEBUTTONDOWN:
			break;
		case SDL_MOUSEMOTION:
//			bc->mousex=event.motion.x;
//			bc->mousey=event.motion.y;
			break;
		case SDL_WINDOWEVENT:
			if(event.window.event == SDL_WINDOWEVENT_EXPOSED)
			{
			} else if(event.window.event == SDL_WINDOWEVENT_RESIZED)
			{
				doresize(ec, event.window.data1, event.window.data2);
			}
			break;
		case SDL_QUIT:
			exitflag = 1;
//			bc->flags |= BF_QUIT;
			break;
		}
	}
//	showpressed();
}


#define FONTW 6
#define FONTH 13

int samples;

void fillaudio(void *data, Uint8 *buffer, int len)
{
len/=sizeof(short)*2;
short *sp;
//int underrun = 0;

	sp = (void *)buffer;
	while(len--)
	{
		if(soundtake != soundput)
		{
			*sp++ = soundbuffer[soundtake];
			*sp++ = soundbuffer[soundtake+1];
			soundtake += 2;
			if(soundtake == SOUNDBUFFERSIZE)
				soundtake = 0;
		} else
		{
			*sp++ = 0;
			*sp++ = 0;
//			underrun = 1;
		}
	}
//	if(underrun) printf("underrun!\n");
}


void soundopen(void)
{
SDL_AudioSpec wanted;

	memset(&wanted,0,sizeof(wanted));
	wanted.freq=SAMPLERATE;
	wanted.channels=2;
	wanted.format=AUDIO_S16;
	wanted.samples=FRAGSIZE;
	wanted.callback=fillaudio;
	wanted.userdata=0;

	if(SDL_OpenAudio(&wanted,0)<0)
	{
		fprintf(stderr,"Couldn't open audio: %s\n",SDL_GetError());
		return;
	}
	samples = wanted.samples;

	SDL_PauseAudio(0);
}

volatile int globaltime;
Uint32 mytimer(Uint32 interval, void *param)
{
int nt;
	nt=globaltime+1;
	if(!nt) ++nt; // my god how anal this is...
	globaltime=nt;
	return 10;
}

void briefdelay(int t)
{
	SDL_Delay(t);
}

void openx(void)
{
	ec *ec = &theec;

	globaltime = 1;

	fontxsize=6;
	fontysize=13;
	xpsize=IXSIZE*zoom;
	ypsize=IYSIZE*zoom;

	if ( SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER) < 0 )
	{
		fprintf(stderr, "Couldn't initialize SDL: %s\n",SDL_GetError());
		exit(1);
	}
	struct xstate *xstate = calloc(1, sizeof(struct xstate));
	ec->xstate = xstate;
	SDL_Window *win = NULL;
	win = SDL_CreateWindow("em", 100, 100, xpsize, ypsize, SDL_WINDOW_HIDDEN);
	SDL_SetWindowResizable(win, 1);
	xstate->renderer = SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED);
	SDL_ShowWindow(win);
	xstate->texture = SDL_CreateTexture(xstate->renderer,SDL_PIXELFORMAT_ARGB8888,
				SDL_TEXTUREACCESS_STREAMING, 320, 224);
	xstate->pixels = malloc(320*224*sizeof(Uint32));
	makefont(ec);

	init_cmap(ec);

	SDL_AddTimer(10, mytimer, 0);

	soundopen();
}
